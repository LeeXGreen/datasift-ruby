var search_data = {"index":{"longSearchIndex":["datasift","datasift::apierror","datasift::accessdeniederror","datasift::apiclient","datasift::compilefailederror","datasift::datasifterror","datasift::definition","datasift::historic","datasift::invaliddataerror","datasift::mockapiclient","datasift::pushdefinition","datasift::pushsubscription","datasift::ratelimitexceedederror","datasift::streamconsumer","datasift::streamconsumer_http","datasift::streamerror","datasift::user","env","object","test","test::unit","test::unit::testcase","testdefinition","testhistorics","testpushdefinition","testpushsubscription","testuser","datasift::apiclient#call()","datasift::mockapiclient#call()","datasift::user#callapi()","test::unit::testcase#checksubscription()","datasift::definition#clearhash()","datasift::mockapiclient#clearresponse()","datasift::definition#compile()","test::unit::testcase#configurepushdefinition()","datasift::streamconsumer#consume()","datasift::user#createdefinition()","datasift::definition#createhistoric()","datasift::user#createhistoric()","datasift::user#createpushdefinition()","datasift::definition#created_at()","datasift::definition#csdl=()","datasift::historic#delete()","datasift::pushsubscription#delete()","env#displayhistoricdetails()","env#displaysubscriptiondetails()","datasift::user#enablessl()","datasift::streamconsumer::factory()","datasift::pushsubscription::get()","datasift::user#getbalance()","datasift::definition#getbuffered()","datasift::definition#getconsumer()","datasift::user#getconsumer()","datasift::definition#getdpubreakdown()","datasift::user#gethistoric()","datasift::pushsubscription#getlog()","datasift::pushsubscription::getlogs()","datasift::user#getpushsubscription()","datasift::user#getpushsubscriptionlog()","datasift::historic#getpushsubscriptions()","datasift::user#getusage()","datasift::user#getuseragent()","datasift::definition#hash()","datasift::historic#hash()","datasift::pushsubscription#init()","test::unit::testcase#init()","datasift::historic#initfromarray()","datasift::historic::list()","datasift::pushsubscription::list()","datasift::pushsubscription::listbyplaybackid()","datasift::pushsubscription::listbystreamhash()","datasift::user#listhistorics()","datasift::user#listpushsubscriptions()","datasift::user#listpushsubscriptionstoplaybackid()","datasift::user#listpushsubscriptionstostreamhash()","datasift::historic#name=()","datasift::pushsubscription#name=()","datasift::apierror::new()","datasift::definition::new()","datasift::historic::new()","datasift::pushdefinition::new()","datasift::pushsubscription::new()","datasift::streamconsumer::new()","datasift::streamconsumer_http::new()","datasift::user::new()","env::new()","object#number_with_delimiter()","datasift::streamconsumer#ondeleted()","datasift::streamconsumer#onerror()","datasift::streamconsumer#onstart()","datasift::streamconsumer_http#onstart()","datasift::streamconsumer#onstop()","datasift::streamconsumer#onstopped()","datasift::streamconsumer#onwarning()","datasift::pushsubscription#pause()","datasift::historic#prepare()","datasift::pushsubscription#reload()","datasift::historic#reloaddata()","datasift::pushsubscription#resume()","datasift::pushsubscription#save()","test::unit::testcase#set204response()","datasift::user#setapiclient()","datasift::mockapiclient#setresponse()","test::unit::testcase#setresponsetoasinglehistoric()","test::unit::testcase#setresponsetoasinglesubscription()","datasift::historic#start()","datasift::historic#stop()","datasift::pushsubscription#stop()","datasift::streamconsumer#stop()","datasift::pushdefinition#subscribe()","datasift::pushdefinition#subscribedefinition()","datasift::pushdefinition#subscribehistoric()","datasift::pushdefinition#subscribehistoricplaybackid()","datasift::pushdefinition#subscribestreamhash()","datasift::definition#total_dpu()","object#usage()","datasift::definition#validate()","datasift::pushdefinition#validate()","","","",""],"info":[["DataSift","","DataSift.html","","<p>This is the official DataSift client library for Ruby.\n"],["DataSift::APIError","","DataSift/APIError.html","","<p>Thrown when an error is found in API responses. These errors optionally\ncarry the HTTP error code.\n"],["DataSift::AccessDeniedError","","DataSift/AccessDeniedError.html","","<p>Thrown when access to the API is denied.\n"],["DataSift::ApiClient","","DataSift/ApiClient.html","","<p>The ApiClient class wraps the functionality that makes calls to the\nDataSift API.\n"],["DataSift::CompileFailedError","","DataSift/CompileFailedError.html","","<p>Thrown when CSDL validation or compilation fails.\n"],["DataSift::DataSiftError","","DataSift/DataSiftError.html","","<p>All exceptions inherit from DataSiftError.\n"],["DataSift::Definition","","DataSift/Definition.html","","<p>The Definition class represents a stream definition.\n"],["DataSift::Historic","","DataSift/Historic.html","","<p>The Historic class represents a Historics query.\n"],["DataSift::InvalidDataError","","DataSift/InvalidDataError.html","","<p>Thrown whenever invalid data is encountered in the library.\n"],["DataSift::MockApiClient","","DataSift/MockApiClient.html","","<p>The MockApiClient class implements a fake DataSift API interface.\n"],["DataSift::PushDefinition","","DataSift/PushDefinition.html","","<p>The PushDefinition class represents a stream definition.\n"],["DataSift::PushSubscription","","DataSift/PushSubscription.html","","<p>The PushSubscription class represents a stream definition.\n"],["DataSift::RateLimitExceededError","","DataSift/RateLimitExceededError.html","","<p>Thrown when you exceed your API rate limit.\n"],["DataSift::StreamConsumer","","DataSift/StreamConsumer.html","","<p>This is the base class for all StreamConsumer implementation.\n"],["DataSift::StreamConsumer_HTTP","","DataSift/StreamConsumer_HTTP.html","","<p>The HTTP implementation of the StreamConsumer.\n"],["DataSift::StreamError","","DataSift/StreamError.html","","<p>Thrown when error occur while reading streaming data.\n"],["DataSift::User","","DataSift/User.html","","<p>The User class represents a user of the API. Applications should start\ntheir API interactions by creating …\n"],["Env","","Env.html","",""],["Object","","Object.html","",""],["Test","","Test.html","",""],["Test::Unit","","Test/Unit.html","",""],["Test::Unit::TestCase","","Test/Unit/TestCase.html","",""],["TestDefinition","","TestDefinition.html","",""],["TestHistorics","","TestHistorics.html","",""],["TestPushDefinition","","TestPushDefinition.html","",""],["TestPushSubscription","","TestPushSubscription.html","",""],["TestUser","","TestUser.html","",""],["call","DataSift::ApiClient","DataSift/ApiClient.html#method-i-call","(username, api_key, endpoint, params = {}, user_agent = 'DataSiftPHP/0.0')","<p>Make a call to a DataSift API endpoint.\n<p>Parameters\n<p><code>endpoint</code> - The endpoint of the API call.\n"],["call","DataSift::MockApiClient","DataSift/MockApiClient.html#method-i-call","(username, api_key, endpoint, params = {}, user_agent = 'DataSiftRuby/0.0')","<p>Fake a call to a DataSift API endpoint.\n<p>Parameters\n<p><code>endpoint</code> - The endpoint of the API call.\n"],["callAPI","DataSift::User","DataSift/User.html#method-i-callAPI","(endpoint, params = {})","<p>Make a call to a DataSift API endpoint.\n<p>Parameters\n<p><code>endpoint</code> - The endpoint of the API call.\n"],["checkSubscription","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-checkSubscription","(subscription)",""],["clearHash","DataSift::Definition","DataSift/Definition.html#method-i-clearHash","()","<p>Reset the hash to false. The effect of this is to mark the definition as\nrequiring compilation.\n"],["clearResponse","DataSift::MockApiClient","DataSift/MockApiClient.html#method-i-clearResponse","()","<p>Clear the response so we throw an exception if we get called again without\na new response being set. …\n"],["compile","DataSift::Definition","DataSift/Definition.html#method-i-compile","()","<p>Call the DataSift API to compile this definition. On success it will store\nthe returned hash.\n"],["configurePushDefinition","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-configurePushDefinition","(push)",""],["consume","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-consume","(auto_reconnect = true, &block)","<p>Once an instance of a StreamConsumer is ready for use, call this to start\nconsuming. Extending classes …\n"],["createDefinition","DataSift::User","DataSift/User.html#method-i-createDefinition","(csdl = '')","<p>Creates and returns a definition object.\n<p>Parameters\n<p><code>csdl</code> - Optional CSDL string with which to prime the …\n"],["createHistoric","DataSift::Definition","DataSift/Definition.html#method-i-createHistoric","(start_date, end_date, sources, sample, name)","<p>Create a Historics query based on this Definition.\n<p>Parameters\n<p><code>start_date</code> - The start date for a new Historics …\n"],["createHistoric","DataSift::User","DataSift/User.html#method-i-createHistoric","(hash, start_date, end_date, sources, sample, name)","<p>Create a Historics query based on this Definition.\n<p>Parameters\n<p><code>hash</code> - The stream hash for a new Historics …\n"],["createPushDefinition","DataSift::User","DataSift/User.html#method-i-createPushDefinition","()","<p>Create a new PushDefinition object for this user.\n<p>Returns\n<p>A PushDefinition object.\n"],["created_at","DataSift::Definition","DataSift/Definition.html#method-i-created_at","()","<p>Created at getter.\n"],["csdl=","DataSift::Definition","DataSift/Definition.html#method-i-csdl-3D","(csdl)","<p>CSDL setter. Strips the incoming string and resets the hash if it’s\nchanged.\n"],["delete","DataSift::Historic","DataSift/Historic.html#method-i-delete","()","<p>Delete this Historics query.\n"],["delete","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-delete","()","<p>Delete this subscription.\n"],["displayHistoricDetails","Env","Env.html#method-i-displayHistoricDetails","(historic)",""],["displaySubscriptionDetails","Env","Env.html#method-i-displaySubscriptionDetails","(subscription)",""],["enableSSL","DataSift::User","DataSift/User.html#method-i-enableSSL","(use_ssl = true)","<p>Sets whether to use SSL for API and stream communication.\n<p>Parameters\n<p><code>use_ssl</code> - Pass true to use SSL.\n"],["factory","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-c-factory","(user, type, definition)","<p>Factory function. Creates a StreamConsumer-derived object for the given\ntype.\n<p>Parameters\n<p><code>type</code> - Use the …\n"],["get","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-get","(user, id)","<p>Get a single Push subscription by ID.\n<p>Parameters\n<p><code>id</code> - The subscription ID.\n"],["getBalance","DataSift::User","DataSift/User.html#method-i-getBalance","()","<p>Returns the account balance information for this user.\n<p>Returns\n<p>A Hash containing the balance information. …\n"],["getBuffered","DataSift::Definition","DataSift/Definition.html#method-i-getBuffered","(count = false, from_id = false)","<p>Call the DataSift API to get buffered interactions.\n<p>Parameters\n<p><code>count</code> - Optional number of interactions …\n"],["getConsumer","DataSift::Definition","DataSift/Definition.html#method-i-getConsumer","(type = nil, on_interaction = nil, on_stopped = nil)","<p>Returns a StreamConsumer-derived object for this definition, for the given\ntype.\n<p>Parameters\n<p><code>type</code> - The …\n"],["getConsumer","DataSift::User","DataSift/User.html#method-i-getConsumer","(type = nil, hash = nil, on_interaction = nil, on_stopped = nil)","<p>Returns a StreamConsumer-derived object for the given hash, for the given\ntype.\n<p>Parameters\n<p><code>type</code> - The consumer …\n"],["getDPUBreakdown","DataSift::Definition","DataSift/Definition.html#method-i-getDPUBreakdown","()","<p>Call the DataSift API to get the DPU for this definition. Returns\n<p>Returns\n<p>A Hash containing…\n"],["getHistoric","DataSift::User","DataSift/User.html#method-i-getHistoric","(playback_id)","<p>Get a Historics query from the API.\n<p>Parameters\n<p><code>playback_id</code> - The playback ID of the Historics query to …\n"],["getLog","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-getLog","(page = 1, per_page = 20, order_by = ORDERBY_REQUEST_TIME, order_dir = ORDERDIR_DESC)","<p>Get a page of the log for this subscription, ordered as specified.\n<p>Parameters\n<p><code>page</code> - The page number to …\n"],["getLogs","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-getLogs","(user, page = 1, per_page = 20, order_by = ORDERBY_REQUEST_TIME, order_dir = ORDERDIR_DESC, id = false)","<p>Page through recent Push subscription log entries, specifying the sort\norder.\n<p>Parameters\n<p><code>user</code> - The user …\n"],["getPushSubscription","DataSift::User","DataSift/User.html#method-i-getPushSubscription","(subscription_id)","<p>Get an existing PushSubscription from the API.\n<p>Parameters\n<p><code>subscription_id</code> - The ID of the subscription …\n"],["getPushSubscriptionLog","DataSift::User","DataSift/User.html#method-i-getPushSubscriptionLog","(subscription_id = false)","<p>Get the log entries for all push subscription or the given subscription.\n<p>Parameters\n<p><code>subscription_id</code> -  …\n"],["getPushSubscriptions","DataSift::Historic","DataSift/Historic.html#method-i-getPushSubscriptions","(page = 1, per_page = 20, order_by = PushSubscription::ORDERBY_CREATED_AT, order_dir = PushSubscription::ORDERDIR_ASC)","<p>Get a page of Push subscriptions for this Historics query, where each page\ncontains up to per_page items. …\n"],["getUsage","DataSift::User","DataSift/User.html#method-i-getUsage","(period = 'hour')","<p>Returns the usage data for this user. If a hash is provided then a more\ndetailed breakdown using interaction …\n"],["getUserAgent","DataSift::User","DataSift/User.html#method-i-getUserAgent","()","<p>Returns the user agent this library should use for all API calls.\n<p>Returns\n<p>The user agent string.\n"],["hash","DataSift::Definition","DataSift/Definition.html#method-i-hash","()","<p>Hash getter. If the hash has not yet been obtained the CSDL will be\ncompiled first.\n"],["hash","DataSift::Historic","DataSift/Historic.html#method-i-hash","()","<p>Getter for the playback ID. If the Historics query has not yet been\nprepared that will be done automagically …\n"],["init","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-init","(data)","<p>Extract the subscription data from a Hash.\n<p>Parameters\n<p><code>data</code> - The Hash containing the subscription data. …\n"],["init","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-init","()",""],["initFromArray","DataSift::Historic","DataSift/Historic.html#method-i-initFromArray","(data)","<p>Initialise this obejct from the data in a Hash.\n<p>Parameters\n<p><code>data</code> - The Hash containing the data.\n"],["list","DataSift::Historic","DataSift/Historic.html#method-c-list","(user, page = 1, per_page = 20)","<p>Get a list of Historics queries in your account.\n<p>Parameters\n<p><code>user</code> - The user object making the request. …\n"],["list","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-list","(user, page = 1, per_page = 20, order_by = ORDERBY_CREATED_AT, order_dir = ORDERDIR_ASC, include_finished = false, hash_type = false, hash = false)","<p>Get a page of Push subscriptions in the given user’s account, where each\npage contains up to per_page …\n"],["listByPlaybackId","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-listByPlaybackId","(user, playback_id, page = 1, per_page = 20, order_by = ORDERBY_CREATED_AT, order_dir = ORDERDIR_ASC, include_finished = false)","<p>Get a page of Push subscriptions for the given stream hash, where each page\ncontains up to per_page items. …\n"],["listByStreamHash","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-listByStreamHash","(user, hash, page = 1, per_page = 20, order_by = ORDERBY_CREATED_AT, order_dir = ORDERDIR_ASC)","<p>Get a page of Push subscriptions for the given stream hash, where each page\ncontains up to per_page items. …\n"],["listHistorics","DataSift::User","DataSift/User.html#method-i-listHistorics","(page = 1, per_page = 20)","\n<pre>Get a list of Historics queries in your account.</pre>\n<p>Parameters\n<p><code>page</code> - The page number to get.\n"],["listPushSubscriptions","DataSift::User","DataSift/User.html#method-i-listPushSubscriptions","(page = 1, per_page = 20, order_by = PushSubscription::ORDERBY_CREATED_AT, order_dir = PushSubscription::ORDERDIR_ASC, include_finished = false)","<p>Get a page of Push subscriptions in the given user’s account, where each\npage contains up to per_page …\n"],["listPushSubscriptionsToPlaybackId","DataSift::User","DataSift/User.html#method-i-listPushSubscriptionsToPlaybackId","(playback_id, page = 1, per_page = 20, order_by = PushSubscription::ORDERBY_CREATED_AT, order_dir = PushSubscription::ORDERDIR_ASC, include_finished = false)","<p>Get a page of Push subscriptions in the given user’s account, where each\npage contains up to per_page …\n"],["listPushSubscriptionsToStreamHash","DataSift::User","DataSift/User.html#method-i-listPushSubscriptionsToStreamHash","(hash, page = 1, per_page = 20, order_by = PushSubscription::ORDERBY_CREATED_AT, order_dir = PushSubscription::ORDERDIR_ASC, include_finished = false)","<p>Get a page of Push subscriptions in the given user’s account, where each\npage contains up to per_page …\n"],["name=","DataSift::Historic","DataSift/Historic.html#method-i-name-3D","(new_name)","<p>Name setter. Updates via the API if this Historics query has already been\nprepared.\n"],["name=","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-name-3D","(new_name)","<p>Name setter. Raises an InvalidDataError if this subscription has been\ndeleted.\n"],["new","DataSift::APIError","DataSift/APIError.html#method-c-new","(http_code = -1)","<p>Constructor.\n<p>Parameters\n<p><code>http_code</code> - Optional HTTP status code.\n"],["new","DataSift::Definition","DataSift/Definition.html#method-c-new","(user, csdl = '', hash = false)","<p>Constructor. A User object is required, and you can optionally supply a\ndefault CSDL string.\n<p>Parameters …\n"],["new","DataSift::Historic","DataSift/Historic.html#method-c-new","(user, hash, start_date = false, end_date = false, sources = false, sample = false, name = false)","<p>Constructor. Pass all parameters to create a new Historics query, or\nprovide a User object and a playback_id …\n"],["new","DataSift::PushDefinition","DataSift/PushDefinition.html#method-c-new","(user)","<p>Constructor. A User object is required.\n<p>Parameters\n<p><code>user</code> - The DataSift::User object.\n"],["new","DataSift::PushSubscription","DataSift/PushSubscription.html#method-c-new","(user, data)","<p>Constructor. A User object is required, along with a Hash containing the\nsubscription data.\n<p>Parameters …\n"],["new","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-c-new","(user, definition)","<p>Constructor. Do not use this directly, use the factory method instead.\n<p>Parameters\n<p><code>user</code> - The user this …\n"],["new","DataSift::StreamConsumer_HTTP","DataSift/StreamConsumer_HTTP.html#method-c-new","(user, definition)","<p>Constructor. Requires valid user and definition objects.\n<p>Parameters\n<p><code>user</code> - The user consuming the data. …\n"],["new","DataSift::User","DataSift/User.html#method-c-new","(username, api_key, use_ssl = true)","<p>Constructor. A username and API key are required when constructing an\ninstance of this class.\n<p>Parameters …\n"],["new","Env","Env.html#method-c-new","(args = false)",""],["number_with_delimiter","Object","Object.html#method-i-number_with_delimiter","(number, delimiter=',')","<p>Function to format a number with commas\n"],["onDeleted","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onDeleted","(&block)","<p>Called when a deletion notification is received.\n<p>Parameters\n<p><code>interaction</code> - Minimal details about the interaction …\n"],["onError","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onError","(&block)","<p>This is called when an error message is received.\n<p>Parameters\n<p><code>message</code> - The error message.\n"],["onStart","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onStart","()","<p>Called when the consumer should start consuming the stream.\n"],["onStart","DataSift::StreamConsumer_HTTP","DataSift/StreamConsumer_HTTP.html#method-i-onStart","(&block)","<p>Called when the consumer is started.\n<p>Parameters\n<p><code>block</code> - A block to receive incoming data.\n"],["onStop","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onStop","(reason = '')","<p>Default implementation of onStop. It’s unlikely that this method will\never be used in isolation, but …\n"],["onStopped","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onStopped","(&block)","<p>This is called when the consumer is stopped.\n<p>Parameters\n<p><code>reason</code> - The reason why the consumer stopped.\n"],["onWarning","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-onWarning","(&block)","<p>This is called when an error message is received.\n<p>Parameters\n<p><code>message</code> - The error message.\n"],["pause","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-pause","()","<p>Pause this subscription.\n"],["prepare","DataSift::Historic","DataSift/Historic.html#method-i-prepare","()","<p>Call the DataSift API to prepare this Historics query\n"],["reload","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-reload","()","<p>Reload the data for this subscription from the API.\n"],["reloadData","DataSift::Historic","DataSift/Historic.html#method-i-reloadData","()","<p>Reload the data for this object from the API.\n"],["resume","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-resume","()","<p>Resume this subscription.\n"],["save","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-save","()","<p>Save changes to the name and output_params to the API.\n"],["set204Response","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-set204Response","()",""],["setApiClient","DataSift::User","DataSift/User.html#method-i-setApiClient","(client)","<p>Sets the ApiClient object to use to access the API\n<p>Parameters\n<p><code>client</code> - The API client object to be used. …\n"],["setResponse","DataSift::MockApiClient","DataSift/MockApiClient.html#method-i-setResponse","(code, data, rate_limit, rate_limit_remaining)","<p>Set the response to be returned by the call method\n<p>Parameters\n<p><code>code</code> - The HTTP response code\n"],["setResponseToASingleHistoric","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-setResponseToASingleHistoric","(changes = {})",""],["setResponseToASingleSubscription","Test::Unit::TestCase","Test/Unit/TestCase.html#method-i-setResponseToASingleSubscription","(changes = {})",""],["start","DataSift::Historic","DataSift/Historic.html#method-i-start","()","<p>Start this Historics query.\n"],["stop","DataSift::Historic","DataSift/Historic.html#method-i-stop","()","<p>Stop this Historics query.\n"],["stop","DataSift::PushSubscription","DataSift/PushSubscription.html#method-i-stop","()","<p>Stop this subscription.\n"],["stop","DataSift::StreamConsumer","DataSift/StreamConsumer.html#method-i-stop","()","<p>This method can be called at any time to <strong>request</strong> that the\nconsumer stop consuming. This method sets the …\n"],["subscribe","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-subscribe","(hash_type, hash, name)","<p>Subscribe this endpoint to a hash.\n<p>Parameters\n<p><code>hash_type</code> - The hash type.\n"],["subscribeDefinition","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-subscribeDefinition","(definition, name)","<p>Subscribe this endpoint to a Definition.\n<p>Parameters\n<p><code>definition</code> - The Definition object.\n"],["subscribeHistoric","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-subscribeHistoric","(historic, name)","<p>Subscribe this endpoint to a Historics query.\n<p>Parameters\n<p><code>historic</code> - The Historic object.\n"],["subscribeHistoricPlaybackId","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-subscribeHistoricPlaybackId","(playback_id, name)","<p>Subscribe this endpoint to a Historics playback ID.\n<p>Parameters\n<p><code>playback_id</code> - The playback ID.\n"],["subscribeStreamHash","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-subscribeStreamHash","(hash, name)","<p>Subscribe this endpoint to a stream hash.\n<p>Parameters\n<p><code>hash</code> - The stream hash.\n"],["total_dpu","DataSift::Definition","DataSift/Definition.html#method-i-total_dpu","()","<p>Total DPU getter.\n"],["usage","Object","Object.html#method-i-usage","(message = '', end_of_story = true)","<p>Display usage information, with an error message if provided.\n"],["validate","DataSift::Definition","DataSift/Definition.html#method-i-validate","()","<p>Call the DataSift API to validate this definition. On success it will store\nthe details in the response. …\n"],["validate","DataSift::PushDefinition","DataSift/PushDefinition.html#method-i-validate","()","<p>Validate the output type and parameters with the DataSift API.\n"],["Gemfile","","Gemfile.html","","<p>source :rubygems gemspec\n"],["LICENSE","","LICENSE.html","","<p>Copyright © 2011-2012 MediaSift Ltd\n<p>Permission is hereby granted, free of charge, to any person obtaining …\n"],["Rakefile","","Rakefile.html","","<p>require ‘rubygems’ require ‘rake’\n<p>require ‘rake/testtask’ Rake::TestTask.new(:test) do |test|\n\n<pre>test.libs ...</pre>\n"],["VERSION","","VERSION.html","","<p>2.0.2\n"]],"searchIndex":["datasift","apierror","accessdeniederror","apiclient","compilefailederror","datasifterror","definition","historic","invaliddataerror","mockapiclient","pushdefinition","pushsubscription","ratelimitexceedederror","streamconsumer","streamconsumer_http","streamerror","user","env","object","test","unit","testcase","testdefinition","testhistorics","testpushdefinition","testpushsubscription","testuser","call()","call()","callapi()","checksubscription()","clearhash()","clearresponse()","compile()","configurepushdefinition()","consume()","createdefinition()","createhistoric()","createhistoric()","createpushdefinition()","created_at()","csdl=()","delete()","delete()","displayhistoricdetails()","displaysubscriptiondetails()","enablessl()","factory()","get()","getbalance()","getbuffered()","getconsumer()","getconsumer()","getdpubreakdown()","gethistoric()","getlog()","getlogs()","getpushsubscription()","getpushsubscriptionlog()","getpushsubscriptions()","getusage()","getuseragent()","hash()","hash()","init()","init()","initfromarray()","list()","list()","listbyplaybackid()","listbystreamhash()","listhistorics()","listpushsubscriptions()","listpushsubscriptionstoplaybackid()","listpushsubscriptionstostreamhash()","name=()","name=()","new()","new()","new()","new()","new()","new()","new()","new()","new()","number_with_delimiter()","ondeleted()","onerror()","onstart()","onstart()","onstop()","onstopped()","onwarning()","pause()","prepare()","reload()","reloaddata()","resume()","save()","set204response()","setapiclient()","setresponse()","setresponsetoasinglehistoric()","setresponsetoasinglesubscription()","start()","stop()","stop()","stop()","subscribe()","subscribedefinition()","subscribehistoric()","subscribehistoricplaybackid()","subscribestreamhash()","total_dpu()","usage()","validate()","validate()","gemfile","license","rakefile","version"]}}